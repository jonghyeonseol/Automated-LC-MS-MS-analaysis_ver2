<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§¬ Interactive Ganglioside Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        /* ì—…ë¡œë“œ ì˜ì—­ */
        .upload-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .file-upload {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-upload:hover {
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.05);
        }

        .file-upload.dragover {
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        /* ì„¤ì • íŒ¨ë„ */
        .control-panel {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .control-item {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
        }

        .control-item label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .slider {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: rgba(255,255,255,0.3);
            outline: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .value-display {
            background: rgba(255,255,255,0.2);
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }

        .parameter-info {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .mode-option {
            flex: 1;
            padding: 12px;
            text-align: center;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .mode-option.active {
            background: rgba(255,255,255,0.3);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn-primary {
            background: #e74c3c;
            color: white;
        }

        .btn-primary:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
            transform: translateY(-2px);
        }

        /* ê²°ê³¼ ì˜ì—­ */
        .results-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            display: none;
        }

        .status-display {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #3498db;
        }

        /* ì‹œê°í™” ì˜ì—­ */
        .visualization-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            display: none;
        }

        /* í•„í„° íŒ¨ë„ */
        .filter-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .filter-section {
            margin-bottom: 15px;
        }

        .filter-section h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .filter-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ddd;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-checkbox:hover {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .filter-checkbox.active {
            background: #2196f3;
            color: white;
            border-color: #2196f3;
        }

        /* ì°¨íŠ¸ ì»¨í…Œì´ë„ˆ */
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .chart-container {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }

        .chart-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            color: #2c3e50;
        }

        /* í†µê³„ ëŒ€ì‹œë³´ë“œ */
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
        .loading {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ë°˜ì‘í˜• ë””ìì¸ */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- í—¤ë” -->
        <div class="header">
            <h1>ğŸ§¬ Interactive Ganglioside Analyzer</h1>
            <p>ì‚°ì„± ë‹¹ì§€ì§ˆ LC-MS/MS ë°ì´í„° ìë™ ë¶„ì„ ë° ì‹œê°í™” í”Œë«í¼</p>
        </div>

        <!-- íŒŒì¼ ì—…ë¡œë“œ ì„¹ì…˜ -->
        <div class="upload-section">
            <h2 style="text-align: center; margin-bottom: 20px;">ğŸ“ ë°ì´í„° ì—…ë¡œë“œ</h2>
            <div class="file-upload" id="fileUpload" onclick="document.getElementById('csvFile').click();">
                <div style="font-size: 3em; margin-bottom: 15px;">ğŸ“„</div>
                <h3>CSV íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”</h3>
                <p>í´ë¦­í•˜ê±°ë‚˜ íŒŒì¼ì„ ë“œë˜ê·¸í•´ì„œ ì—…ë¡œë“œ</p>
                <input type="file" id="csvFile" accept=".csv" style="display: none;">
            </div>
        </div>

        <!-- ì„¤ì • íŒ¨ë„ -->
        <div class="control-panel">
            <h3 style="margin-top: 0; text-align: center; font-size: 1.8em;">âš™ï¸ ì‹¤ì‹œê°„ ë¶„ì„ ì„¤ì •</h3>
            <p style="text-align: center; opacity: 0.9; margin-bottom: 20px;">ì„¤ì •ì„ ë³€ê²½í•˜ë©´ ì¦‰ì‹œ ì¬ë¶„ì„ì´ ìˆ˜í–‰ë©ë‹ˆë‹¤</p>
            
            <div class="control-grid">
                <div class="control-item">
                    <label for="outlierThreshold">ğŸ“Š í‘œì¤€í™” ì”ì°¨ ì„ê³„ê°’</label>
                    <div class="slider-container">
                        <input type="range" id="outlierThreshold" class="slider" min="1.0" max="5.0" step="0.1" value="3.0">
                        <div class="value-display" id="outlierValue">3.0</div>
                    </div>
                    <div class="parameter-info">ì´ìƒì¹˜ íŒë³„ ê¸°ì¤€ (ë†’ì„ìˆ˜ë¡ ì—„ê²©)</div>
                </div>
                
                <div class="control-item">
                    <label for="r2Threshold">ğŸ“ˆ ê²°ì •ê³„ìˆ˜ (RÂ²) ì„ê³„ê°’</label>
                    <div class="slider-container">
                        <input type="range" id="r2Threshold" class="slider" min="0.90" max="0.999" step="0.001" value="0.99">
                        <div class="value-display" id="r2Value">0.990</div>
                    </div>
                    <div class="parameter-info">íšŒê·€ë¶„ì„ í’ˆì§ˆ ê¸°ì¤€ (ë†’ì„ìˆ˜ë¡ ì—„ê²©)</div>
                </div>
                
                <div class="control-item">
                    <label for="rtTolerance">â±ï¸ RT í—ˆìš© ë²”ìœ„ (ë¶„)</label>
                    <div class="slider-container">
                        <input type="range" id="rtTolerance" class="slider" min="0.05" max="0.5" step="0.01" value="0.1">
                        <div class="value-display" id="rtValue">Â±0.10</div>
                    </div>
                    <div class="parameter-info">ë™ì¼ ì ‘ë¯¸ì‚¬ ê·¸ë£¹ ë‚´ RT í—ˆìš© ì˜¤ì°¨</div>
                </div>
                
                <div class="control-item">
                    <label>ğŸ”¬ ë¶„ì„ ëª¨ë“œ</label>
                    <div class="mode-selector">
                        <div class="mode-option active" data-mode="Porcine" onclick="selectMode('Porcine')">
                            ğŸ· Porcine
                        </div>
                        <div class="mode-option" data-mode="Mouse" onclick="selectMode('Mouse')">
                            ğŸ­ Mouse
                        </div>
                    </div>
                    <div class="parameter-info">ë°ì´í„° ì¢…ë¥˜ì— ë”°ë¥¸ ë¶„ì„ ê·œì¹™ ì ìš©</div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-primary" onclick="resetSettings()">ğŸ”„ ê¸°ë³¸ê°’ ë³µì›</button>
                <button class="btn btn-success" onclick="runAnalysis()">ğŸš€ ë¶„ì„ ì‹¤í–‰</button>
            </div>
        </div>

        <!-- ê²°ê³¼ í‘œì‹œ ì˜ì—­ -->
        <div class="results-container" id="resultsContainer">
            <h3>ğŸ“Š ë¶„ì„ ê²°ê³¼</h3>
            <div class="status-display" id="statusDisplay">ëŒ€ê¸° ì¤‘...</div>
            <div id="analysisResults"></div>
            
            <!-- í†µê³„ ëŒ€ì‹œë³´ë“œ -->
            <div class="stats-dashboard" id="statsDashboard" style="display: none;">
                <!-- ë™ì ìœ¼ë¡œ ìƒì„± -->
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn btn-success" onclick="generateVisualization()" id="visualizeBtn" style="display: none;">
                    ğŸ“ˆ ê³ ê¸‰ ì‹œê°í™” ìƒì„±
                </button>
                <button class="btn btn-primary" onclick="downloadResults()" id="downloadBtn" style="display: none;">
                    ğŸ’¾ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ
                </button>
            </div>
        </div>

        <!-- ì‹œê°í™” ì»¨í…Œì´ë„ˆ -->
        <div class="visualization-container" id="visualizationContainer">
            <h3>ğŸ“ˆ ì¸í„°ë™í‹°ë¸Œ ì‹œê°í™”</h3>
            
            <!-- í•„í„° íŒ¨ë„ -->
            <div class="filter-panel">
                <h4>ğŸ” ì‹œê°í™” í•„í„°</h4>
                
                <div class="filter-section">
                    <h5>ì ‘ë‘ì‚¬ë³„ í•„í„° (Prefix Groups)</h5>
                    <div class="filter-checkboxes" id="prefixFilters">
                        <!-- ë™ì ìœ¼ë¡œ ìƒì„± -->
                    </div>
                </div>
                
                <div class="filter-section">
                    <h5>ë¶„ì„ ê·œì¹™ë³„ í•„í„°</h5>
                    <div class="filter-checkboxes" id="ruleFilters">
                        <div class="filter-checkbox active" data-rule="all">
                            <input type="checkbox" checked> ì „ì²´
                        </div>
                        <div class="filter-checkbox" data-rule="rule1">
                            <input type="checkbox"> ê·œì¹™1 (íšŒê·€ë¶„ì„)
                        </div>
                        <div class="filter-checkbox" data-rule="rule4">
                            <input type="checkbox"> ê·œì¹™4 (O-acetylation)
                        </div>
                        <div class="filter-checkbox" data-rule="rule5">
                            <input type="checkbox"> ê·œì¹™5 (RT í•„í„°ë§)
                        </div>
                    </div>
                </div>
                
                <div class="filter-section">
                    <h5>ë°ì´í„° íƒ€ì…ë³„ í•„í„°</h5>
                    <div class="filter-checkboxes" id="typeFilters">
                        <div class="filter-checkbox active" data-type="all">
                            <input type="checkbox" checked> ì „ì²´
                        </div>
                        <div class="filter-checkbox" data-type="valid">
                            <input type="checkbox"> ìœ íš¨ í™”í•©ë¬¼
                        </div>
                        <div class="filter-checkbox" data-type="outlier">
                            <input type="checkbox"> ì´ìƒì¹˜
                        </div>
                        <div class="filter-checkbox" data-type="anchor">
                            <input type="checkbox"> Anchor (T)
                        </div>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 15px;">
                    <button class="btn btn-primary" onclick="applyFilters()">í•„í„° ì ìš©</button>
                    <button class="btn btn-success" onclick="resetFilters()">í•„í„° ì´ˆê¸°í™”</button>
                </div>
            </div>
            
            <!-- ì°¨íŠ¸ ê·¸ë¦¬ë“œ -->
            <div class="chart-grid" id="chartGrid">
                <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë˜ëŠ” ì°¨íŠ¸ë“¤ -->
            </div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let currentAnalysisResults = null;
        let currentSettings = {
            outlierThreshold: 3.0,
            r2Threshold: 0.99,
            rtTolerance: 0.1,
            analysisMode: 'Porcine'
        };
        let uploadedFile = null;
        let allPrefixes = [];
        let filteredData = {
            prefixes: [],
            rules: ['all'],
            types: ['all']
        };

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            setupDragAndDrop();
        });

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì´ˆê¸°í™”
        function initializeEventListeners() {
            // ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸
            document.getElementById('outlierThreshold').addEventListener('input', updateOutlierValue);
            document.getElementById('r2Threshold').addEventListener('input', updateR2Value);
            document.getElementById('rtTolerance').addEventListener('input', updateRtValue);
            
            // íŒŒì¼ ì—…ë¡œë“œ ì´ë²¤íŠ¸
            document.getElementById('csvFile').addEventListener('change', handleFileUpload);
            
            // í•„í„° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
            setupFilterEventListeners();
        }

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì„¤ì •
        function setupDragAndDrop() {
            const fileUpload = document.getElementById('fileUpload');
            
            fileUpload.addEventListener('dragover', function(e) {
                e.preventDefault();
                fileUpload.classList.add('dragover');
            });
            
            fileUpload.addEventListener('dragleave', function(e) {
                e.preventDefault();
                fileUpload.classList.remove('dragover');
            });
            
            fileUpload.addEventListener('drop', function(e) {
                e.preventDefault();
                fileUpload.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].name.endsWith('.csv')) {
                    document.getElementById('csvFile').files = files;
                    handleFileUpload({target: {files: files}});
                }
            });
        }

        // ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë“¤
        function updateOutlierValue(event) {
            const value = parseFloat(event.target.value);
            document.getElementById('outlierValue').textContent = value.toFixed(1);
            currentSettings.outlierThreshold = value;
            
            if (uploadedFile) {
                debounceAnalysis();
            }
        }

        function updateR2Value(event) {
            const value = parseFloat(event.target.value);
            document.getElementById('r2Value').textContent = value.toFixed(3);
            currentSettings.r2Threshold = value;
            
            if (uploadedFile) {
                debounceAnalysis();
            }
        }

        function updateRtValue(event) {
            const value = parseFloat(event.target.value);
            document.getElementById('rtValue').textContent = `Â±${value.toFixed(2)}`;
            currentSettings.rtTolerance = value;
            
            if (uploadedFile) {
                debounceAnalysis();
            }
        }

        // ë¶„ì„ ëª¨ë“œ ì„ íƒ
        function selectMode(mode) {
            document.querySelectorAll('.mode-option').forEach(option => {
                option.classList.remove('active');
            });
            
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
            currentSettings.analysisMode = mode;
            
            if (uploadedFile) {
                debounceAnalysis();
            }
        }

        // ì„¤ì • ì´ˆê¸°í™”
        function resetSettings() {
            currentSettings = {
                outlierThreshold: 3.0,
                r2Threshold: 0.99,
                rtTolerance: 0.1,
                analysisMode: 'Porcine'
            };
            
            document.getElementById('outlierThreshold').value = 3.0;
            document.getElementById('r2Threshold').value = 0.99;
            document.getElementById('rtTolerance').value = 0.1;
            document.getElementById('outlierValue').textContent = '3.0';
            document.getElementById('r2Value').textContent = '0.990';
            document.getElementById('rtValue').textContent = 'Â±0.10';
            
            selectMode('Porcine');
            
            if (uploadedFile) {
                runAnalysis();
            }
        }

        // íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.csv')) {
                showStatus('âŒ CSV íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.', 'error');
                return;
            }
            
            uploadedFile = file;
            showStatus(`âœ… íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ: ${file.name}`, 'success');
            document.getElementById('resultsContainer').style.display = 'block';
        }

        // ë””ë°”ìš´ìŠ¤ ë¶„ì„ ì‹¤í–‰
        let analysisTimeout;
        function debounceAnalysis() {
            clearTimeout(analysisTimeout);
            analysisTimeout = setTimeout(() => {
                runAnalysis(true);
            }, 1000);
        }

        // ë¶„ì„ ì‹¤í–‰
        async function runAnalysis(isAutoReanalysis = false) {
            if (!uploadedFile) {
                showStatus('âŒ ë¨¼ì € CSV íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.', 'error');
                return;
            }

            try {
                const prefix = isAutoReanalysis ? 'ğŸ”„ ì‹¤ì‹œê°„ ì¬ë¶„ì„' : 'ğŸ”¬ ë¶„ì„';
                showStatus(`${prefix} ì§„í–‰ ì¤‘...`, 'loading');

                const formData = new FormData();
                formData.append('file', uploadedFile);
                formData.append('data_type', currentSettings.analysisMode);
                formData.append('outlier_threshold', currentSettings.outlierThreshold);
                formData.append('r2_threshold', currentSettings.r2Threshold);
                formData.append('rt_tolerance', currentSettings.rtTolerance);

                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.results) {
                    currentAnalysisResults = data;
                    displayAnalysisResults(data.results, isAutoReanalysis);
                    updateStatsDashboard(data.results);
                    extractPrefixes(data.results);
                    
                    document.getElementById('visualizeBtn').style.display = 'inline-block';
                    document.getElementById('downloadBtn').style.display = 'inline-block';
                } else {
                    showStatus(`âŒ ë¶„ì„ ì˜¤ë¥˜: ${data.error}`, 'error');
                }

            } catch (error) {
                showStatus(`âŒ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`, 'error');
            }
        }

        // ìƒíƒœ í‘œì‹œ
        function showStatus(message, type = 'info') {
            const statusDisplay = document.getElementById('statusDisplay');
            statusDisplay.textContent = message;
            
            statusDisplay.className = 'status-display';
            if (type === 'error') {
                statusDisplay.style.borderLeftColor = '#e74c3c';
                statusDisplay.style.background = '#fdf2f2';
            } else if (type === 'success') {
                statusDisplay.style.borderLeftColor = '#27ae60';
                statusDisplay.style.background = '#f2f9f4';
            } else if (type === 'loading') {
                statusDisplay.style.borderLeftColor = '#f39c12';
                statusDisplay.style.background = '#fef9e7';
            } else {
                statusDisplay.style.borderLeftColor = '#3498db';
                statusDisplay.style.background = '#ecf0f1';
            }
        }

        // ë¶„ì„ ê²°ê³¼ í‘œì‹œ
        function displayAnalysisResults(results, isAutoReanalysis = false) {
            const stats = results.statistics;
            const prefix = isAutoReanalysis ? 'ğŸ”„ ì‹¤ì‹œê°„ ì¬ë¶„ì„ ì™„ë£Œ!' : 'ğŸ”¬ ë¶„ì„ ì™„ë£Œ!';
            
            const summary = `${prefix}

=== ë¶„ì„ ìš”ì•½ ===
ì´ í™”í•©ë¬¼ ìˆ˜: ${stats.total_compounds || 'N/A'}
ìœ íš¨ í™”í•©ë¬¼: ${stats.valid_compounds || 'N/A'}
ì´ìƒì¹˜: ${stats.outliers || 'N/A'}
ì„±ê³µë¥ : ${(stats.success_rate || 0).toFixed(1)}%

=== í˜„ì¬ ì„¤ì • ===
í‘œì¤€í™” ì”ì°¨ ì„ê³„ê°’: ${currentSettings.outlierThreshold}
RÂ² ì„ê³„ê°’: ${currentSettings.r2Threshold}
RT í—ˆìš© ë²”ìœ„: Â±${currentSettings.rtTolerance}ë¶„
ë¶„ì„ ëª¨ë“œ: ${currentSettings.analysisMode}

=== ê·œì¹™ë³„ ë¶„ì„ ===
ê·œì¹™1 (íšŒê·€ë¶„ì„): ${stats.rule_breakdown?.rule1_regression || 0}ê°œ ìœ íš¨
ê·œì¹™4 (O-ì•„ì„¸í‹¸í™”): ${stats.rule_breakdown?.rule4_oacetylation || 0}ê°œ ìœ íš¨
ê·œì¹™5 (RT í•„í„°ë§): ${stats.rule_breakdown?.rule5_rt_filtering || 0}ê°œ ìœ íš¨

ë¶„ì„ ìƒíƒœ: ${results.status || 'Unknown'}
ëª©í‘œ ë‹¬ì„±ë„: ${results.target_achievement || 'N/A'}

${isAutoReanalysis ? 'âš¡ ì‹¤ì‹œê°„ ëª¨ë“œ: ì„¤ì • ë³€ê²½ì´ ìë™ ë°˜ì˜ë˜ì—ˆìŠµë‹ˆë‹¤.' : ''}`;

            showStatus(summary, 'success');
        }

        // í†µê³„ ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸
        function updateStatsDashboard(results) {
            const stats = results.statistics;
            const dashboard = document.getElementById('statsDashboard');
            
            dashboard.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${stats.total_compounds || 0}</div>
                    <div class="stat-label">ì´ í™”í•©ë¬¼</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #27ae60, #229954);">
                    <div class="stat-number">${stats.valid_compounds || 0}</div>
                    <div class="stat-label">ìœ íš¨ í™”í•©ë¬¼</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #e74c3c, #c0392b);">
                    <div class="stat-number">${stats.outliers || 0}</div>
                    <div class="stat-label">ì´ìƒì¹˜</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #f39c12, #e67e22);">
                    <div class="stat-number">${(stats.success_rate || 0).toFixed(1)}%</div>
                    <div class="stat-label">ì„±ê³µë¥ </div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);">
                    <div class="stat-number">${stats.anchor_compounds || 0}</div>
                    <div class="stat-label">Anchor í™”í•©ë¬¼</div>
                </div>
            `;
            
            dashboard.style.display = 'grid';
        }

        // ì ‘ë‘ì‚¬ ì¶”ì¶œ
        function extractPrefixes(results) {
            const prefixes = new Set();
            
            // ìœ íš¨ í™”í•©ë¬¼ì—ì„œ ì ‘ë‘ì‚¬ ì¶”ì¶œ
            if (results.valid_compounds) {
                results.valid_compounds.forEach(compound => {
                    const prefix = extractPrefixFromName(compound.Name);
                    if (prefix) prefixes.add(prefix);
                });
            }
            
            // ì´ìƒì¹˜ì—ì„œ ì ‘ë‘ì‚¬ ì¶”ì¶œ
            if (results.outliers) {
                results.outliers.forEach(compound => {
                    const prefix = extractPrefixFromName(compound.Name);
                    if (prefix) prefixes.add(prefix);
                });
            }
            
            allPrefixes = Array.from(prefixes).sort();
            updatePrefixFilters();
        }

        // ì´ë¦„ì—ì„œ ì ‘ë‘ì‚¬ ì¶”ì¶œ (GD1a, GD1b, GM3 ë“±)
        function extractPrefixFromName(name) {
            const match = name.match(/^([A-Z]+\d+[a-z]*)/);
            return match ? match[1] : null;
        }

        // ì ‘ë‘ì‚¬ í•„í„° ì—…ë°ì´íŠ¸
        function updatePrefixFilters() {
            const container = document.getElementById('prefixFilters');
            container.innerHTML = `
                <div class="filter-checkbox active" data-prefix="all">
                    <input type="checkbox" checked> ì „ì²´
                </div>
            `;
            
            allPrefixes.forEach(prefix => {
                const checkbox = document.createElement('div');
                checkbox.className = 'filter-checkbox';
                checkbox.setAttribute('data-prefix', prefix);
                checkbox.innerHTML = `<input type="checkbox"> ${prefix}`;
                container.appendChild(checkbox);
            });
        }

        // í•„í„° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupFilterEventListeners() {
            // ì ‘ë‘ì‚¬ í•„í„°
            document.addEventListener('click', function(e) {
                if (e.target.closest('.filter-checkbox')) {
                    const checkbox = e.target.closest('.filter-checkbox');
                    const input = checkbox.querySelector('input');
                    
                    // ì²´í¬ë°•ìŠ¤ í† ê¸€
                    input.checked = !input.checked;
                    checkbox.classList.toggle('active', input.checked);
                    
                    // ì „ì²´ ì„ íƒ ë¡œì§
                    if (checkbox.dataset.prefix === 'all' || checkbox.dataset.rule === 'all' || checkbox.dataset.type === 'all') {
                        const container = checkbox.parentElement;
                        const otherCheckboxes = container.querySelectorAll('.filter-checkbox:not([data-prefix="all"]):not([data-rule="all"]):not([data-type="all"])');
                        
                        if (input.checked) {
                            otherCheckboxes.forEach(cb => {
                                cb.querySelector('input').checked = false;
                                cb.classList.remove('active');
                            });
                        }
                    } else {
                        // ê°œë³„ í•­ëª© ì„ íƒ ì‹œ ì „ì²´ í•´ì œ
                        const container = checkbox.parentElement;
                        const allCheckbox = container.querySelector('[data-prefix="all"], [data-rule="all"], [data-type="all"]');
                        if (allCheckbox && input.checked) {
                            allCheckbox.querySelector('input').checked = false;
                            allCheckbox.classList.remove('active');
                        }
                    }
                }
            });
        }

        // í•„í„° ì ìš©
        function applyFilters() {
            // ì„ íƒëœ ì ‘ë‘ì‚¬ ìˆ˜ì§‘
            const selectedPrefixes = Array.from(document.querySelectorAll('#prefixFilters .filter-checkbox.active')).map(cb => cb.dataset.prefix);
            const selectedRules = Array.from(document.querySelectorAll('#ruleFilters .filter-checkbox.active')).map(cb => cb.dataset.rule);
            const selectedTypes = Array.from(document.querySelectorAll('#typeFilters .filter-checkbox.active')).map(cb => cb.dataset.type);
            
            filteredData = {
                prefixes: selectedPrefixes,
                rules: selectedRules,
                types: selectedTypes
            };
            
            generateVisualization();
        }

        // í•„í„° ì´ˆê¸°í™”
        function resetFilters() {
            document.querySelectorAll('.filter-checkbox').forEach(cb => {
                const isAll = cb.dataset.prefix === 'all' || cb.dataset.rule === 'all' || cb.dataset.type === 'all';
                cb.querySelector('input').checked = isAll;
                cb.classList.toggle('active', isAll);
            });
            
            applyFilters();
        }

        // ê³ ê¸‰ ì‹œê°í™” ìƒì„±
        function generateVisualization() {
            if (!currentAnalysisResults) {
                showStatus('âŒ ë¶„ì„ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë¶„ì„ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.', 'error');
                return;
            }

            try {
                showStatus('ğŸ“Š ê³ ê¸‰ ì‹œê°í™” ìƒì„± ì¤‘...', 'loading');
                
                // ì‹œê°í™” ì»¨í…Œì´ë„ˆ í‘œì‹œ
                document.getElementById('visualizationContainer').style.display = 'block';
                
                // í•„í„°ë§ëœ ë°ì´í„° ì¤€ë¹„
                const filteredResults = filterAnalysisResults(currentAnalysisResults.results);
                
                // ì°¨íŠ¸ ìƒì„±
                createAllCharts(filteredResults);
                
                showStatus('âœ… ì‹œê°í™” ìƒì„± ì™„ë£Œ!', 'success');
                
            } catch (error) {
                showStatus(`âŒ ì‹œê°í™” ìƒì„± ì¤‘ ì˜¤ë¥˜: ${error.message}`, 'error');
            }
        }

        // ë¶„ì„ ê²°ê³¼ í•„í„°ë§
        function filterAnalysisResults(results) {
            const filtered = {
                valid_compounds: [],
                outliers: [],
                statistics: results.statistics
            };
            
            // ìœ íš¨ í™”í•©ë¬¼ í•„í„°ë§
            if (results.valid_compounds) {
                filtered.valid_compounds = results.valid_compounds.filter(compound => {
                    return shouldIncludeCompound(compound, 'valid');
                });
            }
            
            // ì´ìƒì¹˜ í•„í„°ë§
            if (results.outliers) {
                filtered.outliers = results.outliers.filter(compound => {
                    return shouldIncludeCompound(compound, 'outlier');
                });
            }
            
            return filtered;
        }

        // í™”í•©ë¬¼ í¬í•¨ ì—¬ë¶€ ê²°ì •
        function shouldIncludeCompound(compound, type) {
            // íƒ€ì… í•„í„° í™•ì¸
            if (!filteredData.types.includes('all')) {
                const isAnchor = compound.Anchor === 'T';
                if (type === 'valid' && !filteredData.types.includes('valid')) return false;
                if (type === 'outlier' && !filteredData.types.includes('outlier')) return false;
                if (isAnchor && !filteredData.types.includes('anchor')) return false;
            }
            
            // ì ‘ë‘ì‚¬ í•„í„° í™•ì¸
            if (!filteredData.prefixes.includes('all')) {
                const prefix = extractPrefixFromName(compound.Name);
                if (!filteredData.prefixes.includes(prefix)) return false;
            }
            
            // ê·œì¹™ í•„í„° í™•ì¸ (ì¶”í›„ êµ¬í˜„ ê°€ëŠ¥)
            
            return true;
        }

        // ëª¨ë“  ì°¨íŠ¸ ìƒì„±
        function createAllCharts(results) {
            const chartGrid = document.getElementById('chartGrid');
            chartGrid.innerHTML = '';
            
            // 1. ì „ì²´ ì‚°ì ë„ (RT vs Log P)
            createScatterPlot(results, 'scatter-main', 'ì „ì²´ ë°ì´í„° ì‚°ì ë„', chartGrid);
            
            // 2. ì ‘ë‘ì‚¬ë³„ ê°œë³„ ì‚°ì ë„
            allPrefixes.forEach(prefix => {
                if (filteredData.prefixes.includes('all') || filteredData.prefixes.includes(prefix)) {
                    createPrefixSpecificScatter(results, prefix, chartGrid);
                }
            });
            
            // 3. íˆìŠ¤í† ê·¸ë¨ (RT ë¶„í¬)
            createHistogram(results, 'histogram-rt', 'RT ë¶„í¬', 'RT', chartGrid);
            
            // 4. íˆìŠ¤í† ê·¸ë¨ (Log P ë¶„í¬)
            createHistogram(results, 'histogram-logp', 'Log P ë¶„í¬', 'Log P', chartGrid);
            
            // 5. ì ‘ë‘ì‚¬ë³„ ì„±ê³µë¥  ë§‰ëŒ€ê·¸ë˜í”„
            createSuccessRateChart(results, chartGrid);
            
            // 6. ê·œì¹™ë³„ ë¶„ë¥˜ íŒŒì´ì°¨íŠ¸
            createRuleBreakdownPie(results, chartGrid);
            
            // 7. ì”ì°¨ ë¶„ì„ ì°¨íŠ¸
            createResidualAnalysisChart(results, chartGrid);
            
            // 8. ìƒê´€ê´€ê³„ íˆíŠ¸ë§µ
            createCorrelationHeatmap(results, chartGrid);
        }

        // ë©”ì¸ ì‚°ì ë„ ìƒì„±
        function createScatterPlot(results, id, title, container) {
            const chartContainer = createChartContainer(id, title, container);
            
            const traces = [];
            
            // ìœ íš¨ í™”í•©ë¬¼
            if (results.valid_compounds && results.valid_compounds.length > 0) {
                const validData = results.valid_compounds;
                const anchors = validData.filter(d => d.Anchor === 'T');
                const nonAnchors = validData.filter(d => d.Anchor !== 'T');
                
                // Anchor í™”í•©ë¬¼
                if (anchors.length > 0) {
                    traces.push({
                        x: anchors.map(d => d['Log P']),
                        y: anchors.map(d => d.RT),
                        mode: 'markers',
                        type: 'scatter',
                        name: 'Anchor (T)',
                        marker: {
                            color: '#3498db',
                            size: 12,
                            symbol: 'diamond',
                            line: { color: 'white', width: 2 }
                        },
                        text: anchors.map(d => d.Name),
                        hovertemplate: '<b>%{text}</b><br>Log P: %{x}<br>RT: %{y}<extra></extra>'
                    });
                }
                
                // ì¼ë°˜ ìœ íš¨ í™”í•©ë¬¼ (ì ‘ë‘ì‚¬ë³„ ìƒ‰ìƒ)
                if (nonAnchors.length > 0) {
                    const prefixGroups = groupByPrefix(nonAnchors);
                    const colors = ['#27ae60', '#9b59b6', '#f39c12', '#e74c3c', '#16a085', '#34495e', '#2ecc71', '#8e44ad'];
                    
                    Object.keys(prefixGroups).forEach((prefix, index) => {
                        const data = prefixGroups[prefix];
                        traces.push({
                            x: data.map(d => d['Log P']),
                            y: data.map(d => d.RT),
                            mode: 'markers',
                            type: 'scatter',
                            name: prefix,
                            marker: {
                                color: colors[index % colors.length],
                                size: 8,
                                line: { color: 'white', width: 1 }
                            },
                            text: data.map(d => d.Name),
                            hovertemplate: '<b>%{text}</b><br>Log P: %{x}<br>RT: %{y}<extra></extra>'
                        });
                    });
                }
            }
            
            // ì´ìƒì¹˜
            if (results.outliers && results.outliers.length > 0) {
                traces.push({
                    x: results.outliers.map(d => d['Log P']),
                    y: results.outliers.map(d => d.RT),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'ì´ìƒì¹˜',
                    marker: {
                        color: 'transparent',
                        size: 10,
                        line: { color: '#e74c3c', width: 2 }
                    },
                    text: results.outliers.map(d => d.Name),
                    hovertemplate: '<b>%{text}</b><br>Log P: %{x}<br>RT: %{y}<br><b>ì´ìƒì¹˜</b><extra></extra>'
                });
            }
            
            const layout = {
                title: title,
                xaxis: { title: 'Log P' },
                yaxis: { title: 'RT (min)' },
                hovermode: 'closest',
                showlegend: true,
                legend: { x: 0.02, y: 0.98 }
            };
            
            Plotly.newPlot(chartContainer.querySelector('.chart-content'), traces, layout, {responsive: true});
        }

        // ì ‘ë‘ì‚¬ë³„ ê°œë³„ ì‚°ì ë„ ìƒì„±
        function createPrefixSpecificScatter(results, prefix, container) {
            const prefixData = {
                valid_compounds: results.valid_compounds ? results.valid_compounds.filter(d => extractPrefixFromName(d.Name) === prefix) : [],
                outliers: results.outliers ? results.outliers.filter(d => extractPrefixFromName(d.Name) === prefix) : []
            };
            
            if (prefixData.valid_compounds.length === 0 && prefixData.outliers.length === 0) return;
            
            const chartContainer = createChartContainer(`scatter-${prefix}`, `${prefix} ì‹œë¦¬ì¦ˆ ì‚°ì ë„`, container);
            
            const traces = [];
            
            // ìœ íš¨ í™”í•©ë¬¼
            if (prefixData.valid_compounds.length > 0) {
                const anchors = prefixData.valid_compounds.filter(d => d.Anchor === 'T');
                const nonAnchors = prefixData.valid_compounds.filter(d => d.Anchor !== 'T');
                
                if (anchors.length > 0) {
                    traces.push({
                        x: anchors.map(d => d['Log P']),
                        y: anchors.map(d => d.RT),
                        mode: 'markers',
                        type: 'scatter',
                        name: 'Anchor (T)',
                        marker: {
                            color: '#3498db',
                            size: 12,
                            symbol: 'diamond',
                            line: { color: 'white', width: 2 }
                        },
                        text: anchors.map(d => d.Name),
                        hovertemplate: '<b>%{text}</b><br>Log P: %{x}<br>RT: %{y}<extra></extra>'
                    });
                }
                
                if (nonAnchors.length > 0) {
                    traces.push({
                        x: nonAnchors.map(d => d['Log P']),
                        y: nonAnchors.map(d => d.RT),
                        mode: 'markers',
                        type: 'scatter',
                        name: 'ìœ íš¨ í™”í•©ë¬¼',
                        marker: {
                            color: '#27ae60',
                            size: 8,
                            line: { color: 'white', width: 1 }
                        },
                        text: nonAnchors.map(d => d.Name),
                        hovertemplate: '<b>%{text}</b><br>Log P: %{x}<br>RT: %{y}<extra></extra>'
                    });
                }
            }
            
            // ì´ìƒì¹˜
            if (prefixData.outliers.length > 0) {
                traces.push({
                    x: prefixData.outliers.map(d => d['Log P']),
                    y: prefixData.outliers.map(d => d.RT),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'ì´ìƒì¹˜',
                    marker: {
                        color: 'transparent',
                        size: 10,
                        line: { color: '#e74c3c', width: 2 }
                    },
                    text: prefixData.outliers.map(d => d.Name),
                    hovertemplate: '<b>%{text}</b><br>Log P: %{x}<br>RT: %{y}<br><b>ì´ìƒì¹˜</b><extra></extra>'
                });
            }
            
            // íšŒê·€ì„  ì¶”ê°€ (ìœ íš¨ í™”í•©ë¬¼ì´ 3ê°œ ì´ìƒì¸ ê²½ìš°)
            if (prefixData.valid_compounds.length >= 3) {
                const xData = prefixData.valid_compounds.map(d => d['Log P']);
                const yData = prefixData.valid_compounds.map(d => d.RT);
                const regression = calculateLinearRegression(xData, yData);
                
                const xMin = Math.min(...xData);
                const xMax = Math.max(...xData);
                const yMin = regression.slope * xMin + regression.intercept;
                const yMax = regression.slope * xMax + regression.intercept;
                
                traces.push({
                    x: [xMin, xMax],
                    y: [yMin, yMax],
                    mode: 'lines',
                    type: 'scatter',
                    name: `íšŒê·€ì„  (RÂ²=${regression.r2.toFixed(3)})`,
                    line: {
                        color: '#9b59b6',
                        width: 2,
                        dash: 'dash'
                    },
                    hovertemplate: `íšŒê·€ì‹: y = ${regression.slope.toFixed(3)}x + ${regression.intercept.toFixed(3)}<br>RÂ² = ${regression.r2.toFixed(3)}<extra></extra>`
                });
            }
            
            const layout = {
                title: `${prefix} ì‹œë¦¬ì¦ˆ`,
                xaxis: { title: 'Log P' },
                yaxis: { title: 'RT (min)' },
                hovermode: 'closest',
                showlegend: true,
                legend: { x: 0.02, y: 0.98 }
            };
            
            Plotly.newPlot(chartContainer.querySelector('.chart-content'), traces, layout, {responsive: true});
        }

        // íˆìŠ¤í† ê·¸ë¨ ìƒì„±
        function createHistogram(results, id, title, property, container) {
            const chartContainer = createChartContainer(id, title, container);
            
            const traces = [];
            
            // ìœ íš¨ í™”í•©ë¬¼
            if (results.valid_compounds && results.valid_compounds.length > 0) {
                traces.push({
                    x: results.valid_compounds.map(d => d[property]),
                    type: 'histogram',
                    name: 'ìœ íš¨ í™”í•©ë¬¼',
                    marker: { color: '#27ae60', opacity: 0.7 },
                    nbinsx: 20
                });
            }
            
            // ì´ìƒì¹˜
            if (results.outliers && results.outliers.length > 0) {
                traces.push({
                    x: results.outliers.map(d => d[property]),
                    type: 'histogram',
                    name: 'ì´ìƒì¹˜',
                    marker: { color: '#e74c3c', opacity: 0.7 },
                    nbinsx: 20
                });
            }
            
            const layout = {
                title: title,
                xaxis: { title: property },
                yaxis: { title: 'ë¹ˆë„' },
                barmode: 'overlay',
                showlegend: true
            };
            
            Plotly.newPlot(chartContainer.querySelector('.chart-content'), traces, layout, {responsive: true});
        }

        // ì„±ê³µë¥  ì°¨íŠ¸ ìƒì„±
        function createSuccessRateChart(results, container) {
            const chartContainer = createChartContainer('success-rate', 'ì ‘ë‘ì‚¬ë³„ ì„±ê³µë¥ ', container);
            
            const prefixStats = calculatePrefixStats(results);
            const prefixes = Object.keys(prefixStats);
            const successRates = prefixes.map(prefix => 
                prefixStats[prefix].total > 0 ? 
                (prefixStats[prefix].valid / prefixStats[prefix].total) * 100 : 0
            );
            
            const traces = [{
                x: prefixes,
                y: successRates,
                type: 'bar',
                marker: {
                    color: successRates.map(rate => 
                        rate >= 90 ? '#27ae60' : 
                        rate >= 70 ? '#f39c12' : '#e74c3c'
                    )
                },
                text: successRates.map(rate => `${rate.toFixed(1)}%`),
                textposition: 'auto',
                hovertemplate: '<b>%{x}</b><br>ì„±ê³µë¥ : %{y:.1f}%<extra></extra>'
            }];
            
            const layout = {
                title: 'ì ‘ë‘ì‚¬ë³„ ì„±ê³µë¥ ',
                xaxis: { title: 'ì ‘ë‘ì‚¬' },
                yaxis: { title: 'ì„±ê³µë¥  (%)' },
                showlegend: false
            };
            
            Plotly.newPlot(chartContainer.querySelector('.chart-content'), traces, layout, {responsive: true});
        }

        // ê·œì¹™ë³„ ë¶„ë¥˜ íŒŒì´ì°¨íŠ¸ ìƒì„±
        function createRuleBreakdownPie(results, container) {
            const chartContainer = createChartContainer('rule-pie', 'ê·œì¹™ë³„ ë¶„ë¥˜ ê²°ê³¼', container);
            
            const stats = results.statistics;
            const ruleData = stats.rule_breakdown || {};
            
            const labels = ['ê·œì¹™1 (íšŒê·€ë¶„ì„)', 'ê·œì¹™4 (O-ì•„ì„¸í‹¸í™”)', 'ê·œì¹™5 (RT í•„í„°ë§)', 'ì´ìƒì¹˜'];
            const values = [
                ruleData.rule1_regression || 0,
                ruleData.rule4_oacetylation || 0,
                ruleData.rule5_rt_filtering || 0,
                stats.outliers || 0
            ];
            const colors = ['#3498db', '#9b59b6', '#f39c12', '#e74c3c'];
            
            const traces = [{
                labels: labels,
                values: values,
                type: 'pie',
                marker: { colors: colors },
                textinfo: 'label+percent+value',
                hovertemplate: '<b>%{label}</b><br>ê°œìˆ˜: %{value}<br>ë¹„ìœ¨: %{percent}<extra></extra>'
            }];
            
            const layout = {
                title: 'ê·œì¹™ë³„ ë¶„ë¥˜ ê²°ê³¼',
                showlegend: true,
                legend: { x: 1.1, y: 0.5 }
            };
            
            Plotly.newPlot(chartContainer.querySelector('.chart-content'), traces, layout, {responsive: true});
        }

        // ì”ì°¨ ë¶„ì„ ì°¨íŠ¸ ìƒì„±
        function createResidualAnalysisChart(results, container) {
            const chartContainer = createChartContainer('residual', 'ì”ì°¨ ë¶„ì„', container);
            
            // ì”ì°¨ ë°ì´í„° ìˆ˜ì§‘ (ìœ íš¨ í™”í•©ë¬¼ì—ì„œ)
            const residualData = [];
            if (results.valid_compounds) {
                results.valid_compounds.forEach(compound => {
                    if (compound.std_residual !== undefined) {
                        residualData.push({
                            name: compound.Name,
                            residual: compound.std_residual,
                            predicted: compound.predicted_rt || compound.RT,
                            actual: compound.RT
                        });
                    }
                });
            }
            
            if (residualData.length === 0) {
                chartContainer.querySelector('.chart-content').innerHTML = '<p style="text-align: center; padding: 50px;">ì”ì°¨ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }
            
            const traces = [{
                x: residualData.map(d => d.predicted),
                y: residualData.map(d => d.residual),
                mode: 'markers',
                type: 'scatter',
                name: 'í‘œì¤€í™” ì”ì°¨',
                marker: {
                    color: residualData.map(d => Math.abs(d.residual) > currentSettings.outlierThreshold ? '#e74c3c' : '#3498db'),
                    size: 8
                },
                text: residualData.map(d => d.name),
                hovertemplate: '<b>%{text}</b><br>ì˜ˆì¸¡ RT: %{x}<br>í‘œì¤€í™” ì”ì°¨: %{y}<extra></extra>'
            }];
            
            // ì„ê³„ê°’ ë¼ì¸ ì¶”ê°€
            const xRange = [Math.min(...residualData.map(d => d.predicted)), Math.max(...residualData.map(d => d.predicted))];
            
            traces.push({
                x: xRange,
                y: [currentSettings.outlierThreshold, currentSettings.outlierThreshold],
                mode: 'lines',
                type: 'scatter',
                name: `ì„ê³„ê°’ (+${currentSettings.outlierThreshold})`,
                line: { color: '#e74c3c', dash: 'dash' },
                showlegend: false
            });
            
            traces.push({
                x: xRange,
                y: [-currentSettings.outlierThreshold, -currentSettings.outlierThreshold],
                mode: 'lines',
                type: 'scatter',
                name: `ì„ê³„ê°’ (-${currentSettings.outlierThreshold})`,
                line: { color: '#e74c3c', dash: 'dash' },
                showlegend: false
            });
            
            const layout = {
                title: 'ì”ì°¨ ë¶„ì„',
                xaxis: { title: 'ì˜ˆì¸¡ RT (min)' },
                yaxis: { title: 'í‘œì¤€í™” ì”ì°¨' },
                hovermode: 'closest',
                showlegend: true
            };
            
            Plotly.newPlot(chartContainer.querySelector('.chart-content'), traces, layout, {responsive: true});
        }

        // ìƒê´€ê´€ê³„ íˆíŠ¸ë§µ ìƒì„±
        function createCorrelationHeatmap(results, container) {
            const chartContainer = createChartContainer('correlation', 'RT-Log P ìƒê´€ê´€ê³„', container);
            
            // ì ‘ë‘ì‚¬ë³„ ìƒê´€ê´€ê³„ ê³„ì‚°
            const correlationData = [];
            const prefixGroups = groupByPrefix([...(results.valid_compounds || []), ...(results.outliers || [])]);
            
            Object.keys(prefixGroups).forEach(prefix => {
                const data = prefixGroups[prefix];
                if (data.length >= 3) {
                    const correlation = calculateCorrelation(
                        data.map(d => d['Log P']),
                        data.map(d => d.RT)
                    );
                    correlationData.push({
                        prefix: prefix,
                        correlation: correlation,
                        count: data.length
                    });
                }
            });
            
            if (correlationData.length === 0) {
                chartContainer.querySelector('.chart-content').innerHTML = '<p style="text-align: center; padding: 50px;">ìƒê´€ê´€ê³„ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }
            
            const traces = [{
                x: correlationData.map(d => d.prefix),
                y: ['RT-Log P ìƒê´€ê´€ê³„'],
                z: [correlationData.map(d => d.correlation)],
                type: 'heatmap',
                colorscale: [
                    [0, '#e74c3c'],
                    [0.5, '#f39c12'],
                    [0.7, '#27ae60'],
                    [1, '#2ecc71']
                ],
                text: correlationData.map(d => `r=${d.correlation.toFixed(3)}\nn=${d.count}`),
                texttemplate: '%{text}',
                showscale: true,
                colorbar: {
                    title: 'ìƒê´€ê³„ìˆ˜ (r)',
                    titleside: 'right'
                }
            }];
            
            const layout = {
                title: 'ì ‘ë‘ì‚¬ë³„ RT-Log P ìƒê´€ê´€ê³„',
                xaxis: { title: 'ì ‘ë‘ì‚¬' },
                yaxis: { title: '' },
                showlegend: false
            };
            
            Plotly.newPlot(chartContainer.querySelector('.chart-content'), traces, layout, {responsive: true});
        }

        // ê²°ê³¼ ë‹¤ìš´ë¡œë“œ
        function downloadResults() {
            if (!currentAnalysisResults) {
                showStatus('âŒ ë¶„ì„ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë¶„ì„ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.', 'error');
                return;
            }
            
            try {
                const csvContent = generateEnhancedCSVFromResults(currentAnalysisResults);
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ganglioside_analysis_results_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                showStatus('ğŸ’¾ í–¥ìƒëœ ë¶„ì„ ê²°ê³¼ê°€ ì„±ê³µì ìœ¼ë¡œ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                
            } catch (error) {
                showStatus(`âŒ ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜: ${error.message}`, 'error');
            }
        }

        // í–¥ìƒëœ CSV ìƒì„±
        function generateEnhancedCSVFromResults(results) {
            let csv = 'Name,RT,Volume,Log P,Anchor,Status,Classification,Predicted_RT,Residual,Std_Residual,Analysis_Settings\n';
            
            const settingsString = `"Outlier:${currentSettings.outlierThreshold}|R2:${currentSettings.r2Threshold}|RT:${currentSettings.rtTolerance}|Mode:${currentSettings.analysisMode}"`;
            
            // ìœ íš¨ í™”í•©ë¬¼ ì¶”ê°€
            if (results.results.valid_compounds) {
                results.results.valid_compounds.forEach(compound => {
                    const predictedRT = compound.predicted_rt ? compound.predicted_rt.toFixed(3) : 'N/A';
                    const residual = compound.residual ? compound.residual.toFixed(3) : 'N/A';
                    const stdResidual = compound.std_residual ? compound.std_residual.toFixed(3) : 'N/A';
                    
                    csv += `"${compound.Name}",${compound.RT},${compound.Volume || 'N/A'},"${compound['Log P']}","${compound.Anchor}","Valid","ì°¸ê°’",${predictedRT},${residual},${stdResidual},${settingsString}\n`;
                });
            }
            
            // ì´ìƒì¹˜ ì¶”ê°€
            if (results.results.outliers) {
                results.results.outliers.forEach(compound => {
                    const reason = compound.outlier_reason || 'Unknown';
                    const predictedRT = compound.predicted_rt ? compound.predicted_rt.toFixed(3) : 'N/A';
                    const residual = compound.residual ? compound.residual.toFixed(3) : 'N/A';
                    const stdResidual = compound.std_residual ? compound.std_residual.toFixed(3) : 'N/A';
                    
                    csv += `"${compound.Name}",${compound.RT},${compound.Volume || 'N/A'},"${compound['Log P']}","${compound.Anchor}","Outlier","ì´ìƒì¹˜: ${reason}",${predictedRT},${residual},${stdResidual},${settingsString}\n`;
                });
            }
            
            return csv;
        }

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        
        // ì°¨íŠ¸ ì»¨í…Œì´ë„ˆ ìƒì„±
        function createChartContainer(id, title, parent) {
            const container = document.createElement('div');
            container.className = 'chart-container';
            container.innerHTML = `
                <div class="chart-title">${title}</div>
                <div class="chart-content" id="${id}" style="height: 400px;"></div>
            `;
            parent.appendChild(container);
            return container;
        }

        // ì ‘ë‘ì‚¬ë³„ ê·¸ë£¹í™”
        function groupByPrefix(compounds) {
            const groups = {};
            compounds.forEach(compound => {
                const prefix = extractPrefixFromName(compound.Name);
                if (prefix) {
                    if (!groups[prefix]) groups[prefix] = [];
                    groups[prefix].push(compound);
                }
            });
            return groups;
        }

        // ì„ í˜• íšŒê·€ ê³„ì‚°
        function calculateLinearRegression(xData, yData) {
            const n = xData.length;
            const sumX = xData.reduce((a, b) => a + b, 0);
            const sumY = yData.reduce((a, b) => a + b, 0);
            const sumXY = xData.reduce((sum, x, i) => sum + x * yData[i], 0);
            const sumXX = xData.reduce((sum, x) => sum + x * x, 0);
            const sumYY = yData.reduce((sum, y) => sum + y * y, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // RÂ² ê³„ì‚°
            const meanY = sumY / n;
            const ssRes = yData.reduce((sum, y, i) => {
                const predicted = slope * xData[i] + intercept;
                return sum + Math.pow(y - predicted, 2);
            }, 0);
            const ssTot = yData.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);
            const r2 = 1 - (ssRes / ssTot);
            
            return { slope, intercept, r2 };
        }

        // ìƒê´€ê³„ìˆ˜ ê³„ì‚°
        function calculateCorrelation(xData, yData) {
            const n = xData.length;
            const sumX = xData.reduce((a, b) => a + b, 0);
            const sumY = yData.reduce((a, b) => a + b, 0);
            const sumXY = xData.reduce((sum, x, i) => sum + x * yData[i], 0);
            const sumXX = xData.reduce((sum, x) => sum + x * x, 0);
            const sumYY = yData.reduce((sum, y) => sum + y * y, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }

        // ì ‘ë‘ì‚¬ë³„ í†µê³„ ê³„ì‚°
        function calculatePrefixStats(results) {
            const stats = {};
            
            // ìœ íš¨ í™”í•©ë¬¼ í†µê³„
            if (results.valid_compounds) {
                results.valid_compounds.forEach(compound => {
                    const prefix = extractPrefixFromName(compound.Name);
                    if (prefix) {
                        if (!stats[prefix]) stats[prefix] = { valid: 0, outlier: 0, total: 0 };
                        stats[prefix].valid++;
                        stats[prefix].total++;
                    }
                });
            }
            
            // ì´ìƒì¹˜ í†µê³„
            if (results.outliers) {
                results.outliers.forEach(compound => {
                    const prefix = extractPrefixFromName(compound.Name);
                    if (prefix) {
                        if (!stats[prefix]) stats[prefix] = { valid: 0, outlier: 0, total: 0 };
                        stats[prefix].outlier++;
                        stats[prefix].total++;
                    }
                });
            }
            
            return stats;
        }

        // ì—ëŸ¬ í•¸ë“¤ë§
        window.addEventListener('error', function(e) {
            console.error('JavaScript Error:', e.error);
            showStatus(`âŒ ì‹œìŠ¤í…œ ì˜¤ë¥˜: ${e.message}`, 'error');
        });

        // ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ ë””ë°”ìš´ìŠ¤ í•¨ìˆ˜
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ë°˜ì‘í˜• ì°¨íŠ¸ ë¦¬ì‚¬ì´ì¦ˆ
        window.addEventListener('resize', debounce(function() {
            const chartContents = document.querySelectorAll('[id^="scatter-"], [id^="histogram-"], [id^="success-rate"], [id^="rule-pie"], [id^="residual"], [id^="correlation"]');
            chartContents.forEach(chart => {
                if (chart.data) {
                    Plotly.Plots.resize(chart);
                }
            });
        }, 250));

        // ì°¨íŠ¸ ìƒí˜¸ì‘ìš© ì„¤ì •
        function setupChartInteractions() {
            // ì°¨íŠ¸ í´ë¦­ ì´ë²¤íŠ¸ ì²˜ë¦¬
            document.addEventListener('plotly_click', function(data) {
                const pointIndex = data.points[0].pointIndex;
                const trace = data.points[0].data;
                const compoundName = trace.text[pointIndex];
                
                // ìƒì„¸ ì •ë³´ í‘œì‹œ
                showCompoundDetails(compoundName);
            });
            
            // ì°¨íŠ¸ í˜¸ë²„ ì´ë²¤íŠ¸ ì²˜ë¦¬
            document.addEventListener('plotly_hover', function(data) {
                // í˜¸ë²„ ì‹œ ì¶”ê°€ ì •ë³´ í‘œì‹œ (ì„ íƒì‚¬í•­)
            });
        }

        // í™”í•©ë¬¼ ìƒì„¸ ì •ë³´ í‘œì‹œ
        function showCompoundDetails(compoundName) {
            let compound = null;
            
            // ë¶„ì„ ê²°ê³¼ì—ì„œ í™”í•©ë¬¼ ì°¾ê¸°
            if (currentAnalysisResults.results.valid_compounds) {
                compound = currentAnalysisResults.results.valid_compounds.find(c => c.Name === compoundName);
            }
            
            if (!compound && currentAnalysisResults.results.outliers) {
                compound = currentAnalysisResults.results.outliers.find(c => c.Name === compoundName);
            }
            
            if (compound) {
                const details = `
ğŸ“ í™”í•©ë¬¼ ìƒì„¸ ì •ë³´

ì´ë¦„: ${compound.Name}
RT: ${compound.RT} min
Log P: ${compound['Log P']}
Volume: ${compound.Volume || 'N/A'}
Anchor: ${compound.Anchor}
ìƒíƒœ: ${compound.outlier_reason ? 'ì´ìƒì¹˜' : 'ìœ íš¨ í™”í•©ë¬¼'}
${compound.outlier_reason ? `ì‚¬ìœ : ${compound.outlier_reason}` : ''}
${compound.predicted_rt ? `ì˜ˆì¸¡ RT: ${compound.predicted_rt.toFixed(3)} min` : ''}
${compound.std_residual ? `í‘œì¤€í™” ì”ì°¨: ${compound.std_residual.toFixed(3)}` : ''}
                `;
                
                showStatus(details, 'info');
            }
        }

        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì„¤ì •
        document.addEventListener('keydown', function(e) {
            // Ctrl+Enter: ë¶„ì„ ì‹¤í–‰
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                runAnalysis();
            }
            
            // Ctrl+S: ê²°ê³¼ ë‹¤ìš´ë¡œë“œ
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (currentAnalysisResults) {
                    downloadResults();
                }
            }
            
            // Ctrl+R: ì„¤ì • ë¦¬ì…‹
            if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                resetSettings();
            }
            
            // V: ì‹œê°í™” ìƒì„±
            if (e.key === 'v' || e.key === 'V') {
                if (currentAnalysisResults && !e.ctrlKey && !e.altKey) {
                    generateVisualization();
                }
            }
        });

        // ì´ˆê¸°í™” ì™„ë£Œ ë©”ì‹œì§€
        console.log('ğŸ§¬ Interactive Ganglioside Analyzer ì´ˆê¸°í™” ì™„ë£Œ!');
        console.log('ğŸ“‹ ì‚¬ìš© ê°€ëŠ¥í•œ ë‹¨ì¶•í‚¤:');
        console.log('  Ctrl+Enter: ë¶„ì„ ì‹¤í–‰');
        console.log('  Ctrl+S: ê²°ê³¼ ë‹¤ìš´ë¡œë“œ');
        console.log('  Ctrl+R: ì„¤ì • ë¦¬ì…‹');
        console.log('  V: ì‹œê°í™” ìƒì„±');

        // ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬
        function checkBrowserCompatibility() {
            const isCompatible = 
                window.File && 
                window.FileReader && 
                window.FileList && 
                window.Blob &&
                window.fetch &&
                window.Promise;
                
            if (!isCompatible) {
                showStatus('âš ï¸ ë¸Œë¼ìš°ì €ê°€ ëª¨ë“  ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìµœì‹  ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.', 'warning');
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ í›„ í˜¸í™˜ì„± ì²´í¬
        window.addEventListener('load', function() {
            checkBrowserCompatibility();
            setupChartInteractions();
        });

        // ë°ì´í„° ê²€ì¦ í•¨ìˆ˜
        function validateCSVData(data) {
            const requiredColumns = ['Name', 'RT', 'Volume', 'Log P', 'Anchor'];
            const missingColumns = [];
            
            requiredColumns.forEach(col => {
                if (!data.includes(col)) {
                    missingColumns.push(col);
                }
            });
            
            return {
                isValid: missingColumns.length === 0,
                missingColumns: missingColumns
            };
        }

        // ë¶„ì„ ì§„í–‰ë¥  í‘œì‹œ
        function updateAnalysisProgress(step, total, message) {
            const percentage = Math.round((step / total) * 100);
            showStatus(`ğŸ”„ ${message} (${percentage}%)`, 'loading');
        }

        // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ (ê°œë°œìš©)
        function monitorMemoryUsage() {
            if (performance.memory) {
                const used = Math.round(performance.memory.usedJSHeapSize / 1048576);
                const total = Math.round(performance.memory.totalJSHeapSize / 1048576);
                console.log(`ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: ${used}MB / ${total}MB`);
            }
        }

        // ì£¼ê¸°ì  ë©”ëª¨ë¦¬ ì²´í¬ (ê°œë°œ ëª¨ë“œì—ì„œë§Œ)
        if (window.location.hostname === 'localhost') {
            setInterval(monitorMemoryUsage, 30000);
        }

        // ì‚¬ìš©ì ê²½í—˜ ê°œì„ ì„ ìœ„í•œ íŒ í‘œì‹œ
        function showUsageTips() {
            const tips = [
                'ğŸ’¡ íŒ: ìŠ¬ë¼ì´ë”ë¥¼ ì¡°ì •í•˜ë©´ ì‹¤ì‹œê°„ìœ¼ë¡œ ì¬ë¶„ì„ì´ ìˆ˜í–‰ë©ë‹ˆë‹¤.',
                'ğŸ¯ íŒ: ì°¨íŠ¸ì˜ ì ì„ í´ë¦­í•˜ë©´ í™”í•©ë¬¼ ìƒì„¸ ì •ë³´ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'âŒ¨ï¸ íŒ: Ctrl+Enterë¡œ ë¹ ë¥´ê²Œ ë¶„ì„ì„ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'ğŸ“Š íŒ: í•„í„°ë¥¼ ì‚¬ìš©í•´ì„œ íŠ¹ì • ì ‘ë‘ì‚¬ë§Œ ì‹œê°í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'ğŸ’¾ íŒ: Ctrl+Së¡œ ë¶„ì„ ê²°ê³¼ë¥¼ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
            ];
            
            let tipIndex = 0;
            setInterval(() => {
                if (!currentAnalysisResults) return;
                
                const tip = tips[tipIndex % tips.length];
                const statusElement = document.getElementById('statusDisplay');
                
                // í˜„ì¬ ìƒíƒœê°€ ì˜¤ë¥˜ë‚˜ ë¡œë”©ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ íŒ í‘œì‹œ
                if (!statusElement.textContent.includes('âŒ') && !statusElement.textContent.includes('ğŸ”„')) {
                    setTimeout(() => {
                        if (!statusElement.textContent.includes('âŒ') && !statusElement.textContent.includes('ğŸ”„')) {
                            showStatus(tip, 'info');
                        }
                    }, 2000);
                }
                
                tipIndex++;
            }, 15000);
        }

        // íŒ í‘œì‹œ ì‹œì‘ (ë¶„ì„ ê²°ê³¼ê°€ ìˆì„ ë•Œ)
        setTimeout(showUsageTips, 5000);

    </script>
</body>
</html>